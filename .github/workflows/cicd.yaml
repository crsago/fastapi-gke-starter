name: CI/CD - GKE + Helm

on:
  push:
    branches: [ "**" ]
    tags:     [ "v*.*.*" ]
  workflow_dispatch: {}

env:
  IMAGE_NAME: hello-app
  CHART_DIR: helm/hello-app
  STAGING_VALUES: environments/values-staging.yaml
  PROD_VALUES: environments/values-production.yaml
  ALLOWED_APPROVERS: '["alice","bob","christ"]'

jobs:
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Auth to GCP (Workload Identity Federation)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: access_token

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure docker auth for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ secrets.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Compute image tags
        id: vars
        run: |
          REPO="${{ secrets.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ secrets.GCP_ARTIFACT_REPO }}/${{ env.IMAGE_NAME }}"
          SHA_TAG="${GITHUB_SHA::12}"
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "sha_tag=$SHA_TAG" >> $GITHUB_OUTPUT
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "is_tag=true" >> $GITHUB_OUTPUT
            echo "tag_name=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "is_tag=false" >> $GITHUB_OUTPUT
            echo "tag_name=${SHA_TAG}" >> $GITHUB_OUTPUT
          fi

      - name: Build image
        working-directory: app
        run: |
          docker build -t "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.sha_tag }}" .

      - name: Push image (SHA)
        run: |
          docker push "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.sha_tag }}"

      - name: Also tag 'staging' on branch builds
        if: ${{ steps.vars.outputs.is_tag == 'false' }}
        run: |
          docker tag "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.sha_tag }}" "${{ steps.vars.outputs.repo }}:staging"
          docker push "${{ steps.vars.outputs.repo }}:staging"

      - name: Also tag SemVer on tag builds
        if: ${{ steps.vars.outputs.is_tag == 'true' }}
        run: |
          docker tag "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.sha_tag }}" "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.tag_name }}"
          docker push "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.tag_name }}"
          docker tag "${{ steps.vars.outputs.repo }}:${{ steps.vars.outputs.sha_tag }}" "${{ steps.vars.outputs.repo }}:production"
          docker push "${{ steps.vars.outputs.repo }}:production"

  deploy_staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build]
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Auth to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: access_token

      - name: Setup gcloud + kubectl + helm
        uses: google-github-actions/setup-gcloud@v2

      - name: Install gke-gcloud-auth-plugin & helm
        run: |
          gcloud components install gke-gcloud-auth-plugin kubectl --quiet
          curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials "${{ secrets.GKE_CLUSTER_NAME }}" --location "${{ secrets.GKE_LOCATION }}"

      - name: helm lint
        run: |
          helm lint "${{ env.CHART_DIR }}" -f "${{ env.STAGING_VALUES }}"

      - name: Sync secrets from GCP Secret Manager to Kubernetes
        run: |
          SECRET_VAL="$(gcloud secrets versions access latest --secret hello-app-secret || true)"
          kubectl create secret generic app-secrets \
            --from-literal=HELLO_APP_SECRET="${SECRET_VAL}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Helm upgrade/install (staging)
        run: |
          helm upgrade --install stg-hello "${{ env.CHART_DIR }}" \
            --namespace default \
            -f "${{ env.STAGING_VALUES }}"

      - name: Smoke check
        run: |
          kubectl rollout status deploy/stg-hello-hello-app --timeout=180s
          kubectl get pods -o wide
          kubectl port-forward svc/stg-hello-hello-app 8080:80 >/tmp/pf.log 2>&1 &
          sleep 3
          curl -sf http://127.0.0.1:8080/ | grep -i "Hello World"
          POD=$(kubectl get pods -l app=stg-hello-hello-app -o jsonpath='{.items[0].metadata.name}')
          ! kubectl logs "$POD" | grep -E "ERROR|Error|Unhandled"
          echo "Staging deployment looks healthy."

  approve:
    name: Manual Approval (Production Gate)
    runs-on: ubuntu-latest
    needs: [deploy_staging]
    environment:
      name: production
    steps:
      - name: Check approver is allowed
        run: |
          ACTOR="${GITHUB_ACTOR}"
          ALLOWED='${{ env.ALLOWED_APPROVERS }}'
          echo "Approval actor: $ACTOR"
          python3 - << 'PY'
          import json, os, sys
          actor=os.environ.get("ACTOR")
          allowed=json.loads(os.environ.get("ALLOWED","[]"))
          if actor in allowed:
            sys.exit(0)
          print(f"Actor {actor} is not in allowed list {allowed}.")
          sys.exit(1)
          PY          

  deploy_production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [approve]
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Ensure SemVer tag for production
        run: |
          if [[ "${GITHUB_REF_TYPE}" != "tag" ]]; then
            echo "Production deploys must be triggered by a SemVer tag (e.g., v1.2.3)."
            exit 1
          fi
          if ! [[ "${GITHUB_REF_NAME}" =~ ^v[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then
            echo "Tag ${GITHUB_REF_NAME} is not SemVer (vMAJOR.MINOR.PATCH)."
            exit 1
          fi

      - name: Auth to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: access_token

      - name: Setup gcloud + kubectl + helm
        uses: google-github-actions/setup-gcloud@v2

      - name: Install gke-gcloud-auth-plugin & helm
        run: |
          gcloud components install gke-gcloud-auth-plugin kubectl --quiet
          curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials "${{ secrets.GKE_CLUSTER_NAME }}" --location "${{ secrets.GKE_LOCATION }}"

      - name: helm lint
        run: |
          helm lint "${{ env.CHART_DIR }}" -f "${{ env.PROD_VALUES }}"

      - name: Sync secrets from GCP Secret Manager to Kubernetes
        run: |
          SECRET_VAL="$(gcloud secrets versions access latest --secret hello-app-secret || true)"
          kubectl create secret generic app-secrets \
            --from-literal=HELLO_APP_SECRET="${SECRET_VAL}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Helm upgrade/install (production)
        run: |
          helm upgrade --install prod-hello "${{ env.CHART_DIR }}" \
            --namespace default \
            -f "${{ env.PROD_VALUES }}"

      - name: Smoke check
        run: |
          kubectl rollout status deploy/prod-hello-hello-app --timeout=180s
          kubectl get pods -o wide
          kubectl port-forward svc/prod-hello-hello-app 8080:80 >/tmp/pf.log 2>&1 &
          sleep 3
          curl -sf http://127.0.0.1:8080/ | grep -i "Hello World"
          POD=$(kubectl get pods -l app=prod-hello-hello-app -o jsonpath='{.items[0].metadata.name}')
          ! kubectl logs "$POD" | grep -E "ERROR|Error|Unhandled"
          echo "Production deployment looks healthy."
